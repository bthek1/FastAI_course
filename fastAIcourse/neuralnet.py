# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/021_how-does-a-neural-net-really-work.ipynb.

# %% auto 0
__all__ = ['plot_function', 'f', 'quad', 'mk_quad', 'noise', 'add_noise', 'plot_quad', 'mae', 'quad_mae', 'rectified_linear',
           'rectified_linear2', 'plot_relu', 'double_relu', 'plot_double_relu']

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 4
#|code-fold: true
#|eval: false
from ipywidgets import interact
from fastai.basics import *

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 5
#|code-fold: true
#|eval: false
plt.rc('figure', dpi=90)

def plot_function(f, title=None, min=-2.1, max=2.1, color='r', ylim=None):
    x = torch.linspace(min,max, 100)[:,None]
    if ylim: plt.ylim(ylim)
    plt.plot(x, f(x), color)
    if title is not None: plt.title(title)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 7
#|code-fold: true
#|eval: false
def f(x): return 3*x**2 + 2*x + 1

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 10
#|code-fold: true
#|eval: false
def quad(a, b, c, x): return a*x**2 + b*x + c

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 12
#|code-fold: true
#|eval: false
def mk_quad(a,b,c): return partial(quad, a,b,c)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 16
#|code-fold: true
#|eval: false
def noise(x, scale): return np.random.normal(scale=scale, size=x.shape)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 17
#|code-fold: true
#|eval: false
def add_noise(x, mult, add): return x * (1+noise(x,mult)) + noise(x,add)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 25
#|code-fold: true
#|eval: false
@interact(a=1.1, b=1.1, c=1.1)
def plot_quad(a, b, c, x, y):
    plt.scatter(x,y)
    plot_function(mk_quad(a,b,c), ylim=(-3,13))

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 28
#|code-fold: true
#|eval: false
def mae(preds, acts): return (torch.abs(preds-acts)).mean()

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 30
#|code-fold: true
#|eval: false
@interact(a=1.1, b=1.1, c=1.1)
def plot_quad(a, b, c, x, y):
    f = mk_quad(a,b,c)
    plt.scatter(x,y)
    loss = mae(f(x), y)
    plot_function(f, ylim=(-3,12), title=f"MAE: {loss:.2f}")

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 34
#|code-fold: true
#|eval: false
def quad_mae(params, x, y):
    f = mk_quad(*params)
    return mae(f(x), y)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 48
#|code-fold: true
#|eval: false
with torch.no_grad():
    abc -= abc.grad*0.01
    loss = quad_mae(abc)
    
print(f'loss={loss:.2f}')

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 50
#|code-fold: true
#|eval: false
for i in range(10):
    loss = quad_mae(abc)
    loss.backward()
    with torch.no_grad(): abc -= abc.grad*0.01
    print(f'step={i}; loss={loss:.2f}')

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 54
#|code-fold: true
#|eval: false
def rectified_linear(m,b,x):
    y = m*x+b
    return torch.clip(y, 0.)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 59
#|code-fold: true
#|eval: false
def rectified_linear2(m,b,x): return F.relu(m*x+b)
plot_function(partial(rectified_linear2, 1,1))

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 61
#|code-fold: true
#|eval: false
@interact(m=1.5, b=1.5)
def plot_relu(m, b):
    plot_function(partial(rectified_linear, m,b), ylim=(-1,4))

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 63
#|code-fold: true
#|eval: false
def double_relu(m1,b1,m2,b2,x):
    return rectified_linear(m1,b1,x) + rectified_linear(m2,b2,x)

# %% ../nbs/021_how-does-a-neural-net-really-work.ipynb 64
#|code-fold: true
#|eval: false
@interact(m1=-1.5, b1=-1.5, m2=1.5, b2=1.5)
def plot_double_relu(m1, b1, m2, b2):
    plot_function(partial(double_relu, m1,b1,m2,b2), ylim=(-1,6))
